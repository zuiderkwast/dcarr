/*********************************************************************
 * dcarr.h - A generic dynamic array for C, implemented as macros.   *
 *                                                                   *
 * 2011 June 22                                                      *
 * The author disclaims copyright to this source code.               *
 *                                                                   *
 * The array uses a circular buffer, thus it has amortized constant  *
 * time insertion/removal at both ends.  This implementation is also *
 * known as an array deque.                                          *
 *********************************************************************/


Introduction
============

This is a small set of macros implementing a dynamic array, using a
circular buffer.  The values can be of any type.  Allocation is done
using malloc and realloc, but you can change this by redifining some
macros.  The capacity is always a power of 2.  This allows for faster
index lookups than other capacities.

Just copy dcarr.h into your project and use it.  There is no library to
link to.

Beeing generic means the values can be of any type.  The array type
has to be defined though, using dcarr_define_type, which expands to a
typedef struct.

Many of the macros require the elements' type as one of the parameters.
This may seem strange, but there is nothing strange about it in the
world of macros.


Macros
======

For full documentation, refer to the comments in the source code.


How to use it, by examples
==========================

First define an array type using the dcarr_define_type.  This example
defines the type my_array_of_double_t to be an array of doubles:

  dcarr_define_type(array_of_double_t, double);

To create an array, declare a variable of your array type and
initialize it.

  array_of_double_t numbers;
  dcarr_init(numbers);

Then add some values using push, unshift and insert.

  dcarr_push(numbers, double, 3.1415926535);
  dcarr_unshift(numbers, double, 42.0);
  dcarr_insert(numbers, 1, double, 99.9);

Access random elements at a given index. Indexing starts at 0, like for
ordinary arrays.

  double d = dcarr_elem(numbers, 2);

It's also possible to assign to dcarr_elem.

  dcarr_elem(numbers, 2) = 123.45;

To remove and element and get the value, use pop and shift. (A macro
for removing at arbitrary positions is yet to be written.)

  dcarr_pop(numbers, double, value);
  dcarr_shift(numbers, double, value);

Print the contents of the array.

  int i;
  for (i=0; i < dcarr_len(numbers); i++)
      printf("Element at %d is %g.\n", i, dcarr_elem(i));

Finally, free all allocated memory.

  dcarr_destroy(numbers);

For more information, refer to dcarr.h. It is quite small.


TODO
====

dcarr_remove
   Remove an element at an arbitrary position and return its value.

dcarr_append, dcarr_prepend, dcarr_insert_all
    Append, prepend and insert another dcarr array.

Macros to insert, appand and prepend multiple elements, from a static
array.

Macros to copy a range to another dcarr and/or to a static array.

A macro to align the array at offset zero by moving the contents.


Related projects
================

SGLIB - A Simple Generic Library for C
http://sglib.sourceforge.net/
"Sglib is a library defining useful macros for manipulating common data
structures."

Uthash - Generic hashtables using macros
http://uthash.sourceforge.net/
